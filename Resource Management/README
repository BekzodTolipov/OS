# tolipov.5

TO RUN:
	In your terminal type following:
	make		//To compile the program
	./oss		//To run the program
	./oss -v	//To run the program with option verbose on

OSS:
	This program is designed to demonstrate how resources are managed in 
	this simulated operating system. The deadlock avoidance strategy was implemented for this
	project by using bankers algorithm. 
	This is the main program and serve as the master process. It will start the process by 
	setting up time, and all shared memories as necessary and will begin fork() system call to
	create child processes for them to execute ./user executable using execvp() at random times.
	The randomness is simulated by simulated system clock which stays at shared memory for child
	to read from it.
	Resources will be simulated by having resources in shared memory and each resource will have
	resource descriptors.
	The resource descriptor has total amount of resources and resources allocator per process and
	accessable to child process.
	After resources initialized to starting point fork() will be executed at random time between
	1 and 500 milleseconds of simulated time.
	There will be only 18 process alive at any given time and new process is created only when
	one of the child process terminates.
	There will be no scheduling in this program but all processes will run concurrently and only
	be put in sleep if their request is not granted.
	Any updates in shared memory is done by oss.
	At the end it will produce statistics regarding how program ran and how many times deadlock
	avoidance ran, request granted. Verbose option is also given to turn on more explanatory
	text messages to display.
	In addtion, current allocated resource table will be printed during execution for every
	20 granted resources.

USER:
	This program will be executed by child processes created in oss and
	they will ask for resource at random times. It will start by generating random time to 
	ask oss for resource or release the resource or terminate. Request/release will be tran-
	sfered by message queue. Programm will continue working untill terminate chance reached.
	The request claims cannot go above max_claims in resource table which is in shared mem-
	ory. It will only ask if request<max_claims. Requests are generated by random number
	which is not allowed to exceed from max_claims. At random time [0, 250] ms program will
	first check if it will terminate or not. It can also ask if its allowed to release the
	resources in it poseccion.

PROBLEM:
	Once blocked queue feels up they are not qualifying to safe state. So once blocked
	queue fills up than program gets stuck.
